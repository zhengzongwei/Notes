<!-- 09/05/2018 21:57 -->

# Python 面向对象的总结

### 1. 有参数的__init__()方法

a. 在类内部获取 属性 和 实例方法，通过self获取；

b. 在类外部获取 属性 和 实例方法，通过对象名获取。

c. 如果一个类有多个对象，每个对象的属性是各自保存的，都有各自独立的地址；

d. 但是实例方法是所有对象共享的，只占用一份内存空间。类会通过self来判断是哪个对象调用了实例方法。

### 2. \_\_del\_\_

a. 监听对象是否销毁

b. 人为销毁对象 del 对象

c. 当地址的引用计数为0的时候,才会执行__del__

### 3. 单继承/多继承

a. 子类继承多个父类

    1) 如果多个父类的方法名相同,子类会默认继承第一个父类的方法
    
    2) 如果父类的属性名相同,子类也会继承第一个父类的属性
    
        i. 为什么会继承第一个父类的属性?
        两个父类都有init方法,默认会继承第一个也会执行第一个init方法

### 4. 子类重写父类的同名属性和方法

a. 子类继承了父类,子类实现了父类的同名方法,做自己特有的事情,叫做重写

1) 子类继承(一个)多个父类
    i. 如果子类重写了父类的同名方法,子类对象调用这个同名方法,会使用子类的

    ii. 继承了父类,没有重写,会使用父类的

    iii. 多个父类的方法名不同,子类会全部继承

2) 当子类调用一个方法的时候

 i. 如果子类有, 使用子类的

 ii. 如果子类没有,就找父类1,如果父类1没有,就找父类2.如果还没有,就会报错

### 5. 子类调用父类的同名属性和方法

a. 当子类继承了父类,且子类重写了父类的同名方法,但是子类想调用父类的同名方法
    格式: 父类名.同名方法(self)

### 6. Super()

a. 如果子类继承了父类,如果子类重写了父类的同名方法,子类还想调用父类的同名方法

a. 父类名.同名方法名(self)  ->多继承

b. Super(子类名,self).同名方法名

c. Super().同名方法名   -> 单继承

总结:

如果子类继承了多个父类(多个父类有相同的方法),而且子类重新定义了这个方法

i. 如果子类想调用这个同名方法:子类有个集中方式  a 方式

ii. 如果子类继承多个父类,但是只想调用第一个父类的这方法 a, b, c

iii. 如果子类想使用不同的父类同名方法,必须使用 a

单继承
使用 a, b, c 均可

### 7. 私有属性 和 私有方法

a.如果子类继承了父类,父类有私有属性,那么私有属性不能被子类继承
子类继承的是父类的公有属性和公用方法

b.如果自定义类中的属性和方法进行私有后,,使用这个类创建的对象,在类的外面,不能访问私有的属性和方法私有的属性可以在类的内部使用

### 8. 私有属性和私有方法的用处

a. 保证数据安全

### 9. 修改私有属性的值

a.  get_私有属性/方法

b.  set_私有属性/方法

### 10. 实力属性和实例方法

a. 实例属性:

 不同的对象,相同的属性名,需要保存不同的属性值,需要单独开辟内存空间

b. 实例方法:

 相同的类,创建出来的不同对象,调用的是同一个方法
 通过实例方法的第一个形参(self) 来判断通过那个对象调用的这个方法

### 11. 类属性和实例属性

a. 类属性：定义在类里面，方法的外面

b. 实例属性： 定义在init方法内部的self

c. 取值

 1) 类名.类属性名  建议这种
 2) 对象名.类属性名
分析 类属性会开辟多少内存
 一个类属性 只需要开辟一次内存，对整个类或者通过这个类创建出来的对象的一个特征的描述

d. 赋值 有且只有一种方式

  格式： 类名.类属性名 = 值

```python

xm=Person("小明",20)
给这个对象添加了一个和类属性名相同的实例属性
xm.country="荷兰"
#获取实例属性的值
print(xm.country)
print(Person.country)
```

### 12. 类方法和静态方法

类方法  @classmethod
a. 获取类属性 -> 类方法

 类名.类方法()
 对象名.类方法名

静态方法 @staticmethod

 a. 调用静态方法
 类名.静态方法名
 对象名.静态方法名

### 13. 单例

class HMTools(object):

``` Python
#
# # 类属性 保存对象
# __instance = None
# # 类属性 判断是否是第一个给对象赋值
# __is_first = True
#
# def __new__(cls, *args, **kwargs):
# # 判断是否是第一次进入new方法(标识第一个通过这个类创建一个对象)
# # 第一次
# if not cls.__instance:
# # 保存到类属性中
# cls.__instance = object.__new__(cls)
#
# return cls.__instance

```

### 14. 异常捕获

a. 格式：
Try - except - else - finally
b. 自定义异常

``` Python
#自定义异常类
classAgeError(Exception):

def__init__(self,age):
self.age=age
def__str__(self):
return"您输入的年龄有误(范围1~100之间),age=%d"%self.age

#创建一个人类名字年龄(1~100)
classPerson(object):

def__init__(self,name,age):
#判断
ifage<1orage>100:
#抛出一个自定义异常
#raise自定义异常类名(实参)
raiseAgeError(age)

#赋值
self.name=name
self.age=age

#小明
xm=Person("小明",99)
print(xm.age)
```

### 15. 模块的导入

a. Import 模块名

 模块名.变量名/函数名/类名

b.  from 模块名 import 变量名/函数名/类名

 使用时不需要写上模块名

c. From 模块名 import *

d. as

 给模块起别名
 Import 模块名 as 新名字
 给变量/函数/类名
 From 变量/函数/类名  as 新名字

### 16. 导入包

Import 包名.模块名
使用格式：包名.模块名

### 17. \_\_all__

只能限制from 模块名 *

在包 init 文件中加入限制条件

``` Python
# 如果在__init__.py文件中 使用__all__ 后面添加执行的元素(模块名)
# 如果在其他的模块中使用该包中的模块 只有all中的元素的对应的模块才可以使用
# 配合 from 包名 import *
__all__ = ["hm_sum", "hm_test"]

```
